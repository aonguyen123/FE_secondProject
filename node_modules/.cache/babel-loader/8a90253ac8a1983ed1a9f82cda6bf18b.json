{"ast":null,"code":"import { useRef, useEffect } from 'react';\nimport isEqual from 'lodash.isequal';\nimport { stringify } from 'use-json-comparison';\nimport hash from 'hash.js';\n/* eslint no-useless-escape:0 import/prefer-default-export:0 */\n\nvar reg = /(((^https?:(?:\\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+(?::\\d+)?|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)$/;\nexport var isUrl = function isUrl(path) {\n  return reg.test(path);\n};\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\nexport var isBrowser = function isBrowser() {\n  return typeof window !== 'undefined' && typeof window.document !== 'undefined' && !isNode;\n};\nexport function guid() {\n  return 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    // eslint-disable-next-line no-bitwise\n    var r = Math.random() * 16 | 0; // eslint-disable-next-line no-bitwise\n\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\nexport var getKeyByPath = function getKeyByPath(item) {\n  var path = item.path,\n      name = item.name;\n\n  if (path && path !== '/') {\n    return path;\n  } // 如果有name, 使用name\n\n\n  if (name) {\n    return name;\n  } // 如果还是没有，用对象的hash 生成一个\n\n\n  try {\n    return hash.sha256().update(stringify(item)).digest('hex');\n  } catch (error) {} // dom some thing\n  // 要是还是不行，返回一个随机值\n\n\n  return guid();\n};\nexport var getOpenKeysFromMenuData = function getOpenKeysFromMenuData(menuData) {\n  if (!menuData) {\n    return undefined;\n  }\n\n  return menuData.reduce(function (pre, item) {\n    if (item.key) {\n      pre.push(item.key);\n    }\n\n    if (item.children) {\n      var newArray = pre.concat(getOpenKeysFromMenuData(item.children) || []);\n      return newArray;\n    }\n\n    return pre;\n  }, []);\n};\n\nfunction deepCompareEquals(a, b) {\n  return isEqual(a, b);\n}\n\nfunction useDeepCompareMemoize(value) {\n  var ref = useRef(); // it can be done by using useMemo as well\n  // but useRef is rather cleaner and easier\n\n  if (!deepCompareEquals(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\nexport function useDeepCompareEffect(effect, dependencies) {\n  useEffect(effect, useDeepCompareMemoize(dependencies));\n}\nvar themeConfig = {\n  daybreak: 'daybreak',\n  '#1890ff': 'daybreak',\n  '#F5222D': 'dust',\n  '#FA541C': 'volcano',\n  '#FAAD14': 'sunset',\n  '#13C2C2': 'cyan',\n  '#52C41A': 'green',\n  '#2F54EB': 'geekblue',\n  '#722ED1': 'purple'\n};\n\nvar invertKeyValues = function invertKeyValues(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    acc[obj[key]] = key;\n    return acc;\n  }, {});\n};\n/**\n * #1890ff -> daybreak\n * @param val\n */\n\n\nexport function genThemeToString(val) {\n  return val && themeConfig[val] ? themeConfig[val] : val;\n}\n/**\n * daybreak-> #1890ff\n * @param val\n */\n\nexport function genStringToTheme(val) {\n  var stringConfig = invertKeyValues(themeConfig);\n  return val && stringConfig[val] ? stringConfig[val] : val;\n}\nexport var usePrevious = function usePrevious(state) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = state;\n  });\n  return ref.current;\n};\nexport function debounce(func, wait, immediate) {\n  // immediate默认为false\n  var timeout;\n  var args;\n  var context;\n  var timestamp;\n  var result; // eslint-disable-next-line no-var\n\n  var later = function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args); // eslint-disable-next-line no-multi-assign\n\n        if (!timeout) context = args = null;\n      }\n    }\n  }; // eslint-disable-next-line func-names\n\n\n  return function () {\n    // @ts-ignore\n    context = this; // eslint-disable-next-line prefer-rest-params\n\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args); // eslint-disable-next-line no-multi-assign\n\n      context = args = null;\n    }\n\n    return result;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}