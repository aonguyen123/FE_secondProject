{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:\\\\web_ungdung\\\\frontend\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = init;\nexports.use = use;\nexports.getItem = getItem;\nexports.compose = compose;\nexports.apply = apply;\nexports.applyForEach = applyForEach;\nexports.mergeConfig = mergeConfig;\nexports.mergeConfigAsync = mergeConfigAsync;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar plugins = null;\nvar validKeys = [];\n\nfunction init() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  plugins = [];\n  validKeys = opts.validKeys || [];\n}\n\nfunction use(plugin) {\n  Object.keys(plugin).forEach(function (key) {\n    // TODO: remove default\n    // default 是为了兼容内部框架内置的一个 babel 插件问题\n    (0, _assert.default)(validKeys.concat('default').indexOf(key) > -1, \"Invalid key \".concat(key, \" from plugin\"));\n  });\n  plugins.push(plugin);\n}\n\nfunction getItem(key) {\n  (0, _assert.default)(validKeys.indexOf(key) > -1, \"Invalid key \".concat(key));\n  return plugins.filter(function (plugin) {\n    return key in plugin;\n  }).map(function (plugin) {\n    return plugin[key];\n  });\n}\n\nfunction _compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  var last = funcs.pop();\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return b(a);\n    };\n  }, last);\n}\n\nfunction compose(item, _ref) {\n  var initialValue = _ref.initialValue;\n  if (typeof item === 'string') item = getItem(item);\n  return function () {\n    return _compose.apply(void 0, _toConsumableArray(item).concat([initialValue]))();\n  };\n}\n\nfunction apply(item, _ref2) {\n  var initialValue = _ref2.initialValue,\n      args = _ref2.args;\n  if (typeof item === 'string') item = getItem(item);\n  (0, _assert.default)(Array.isArray(item), \"item must be Array\");\n  return item.reduce(function (memo, fn) {\n    (0, _assert.default)(typeof fn === 'function', \"applied item must be function\");\n    return fn(memo, args);\n  }, initialValue);\n}\n\nfunction applyForEach(item, _ref3) {\n  var initialValue = _ref3.initialValue;\n  if (typeof item === 'string') item = getItem(item);\n  (0, _assert.default)(Array.isArray(item), \"item must be Array\");\n  item.forEach(function (fn) {\n    (0, _assert.default)(typeof fn === 'function', \"applied item must be function\");\n    fn(initialValue);\n  });\n} // shadow merge\n\n\nfunction mergeConfig(item) {\n  if (typeof item === 'string') item = getItem(item);\n  (0, _assert.default)(Array.isArray(item), \"item must be Array\");\n  return item.reduce(function (memo, config) {\n    (0, _assert.default)((0, _isPlainObject.default)(config), \"Config is not plain object\");\n    return _objectSpread({}, memo, {}, config);\n  }, {});\n}\n\nfunction mergeConfigAsync(_x) {\n  return _mergeConfigAsync.apply(this, arguments);\n}\n\nfunction _mergeConfigAsync() {\n  _mergeConfigAsync = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(item) {\n    var mergedConfig, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, config;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (typeof item === 'string') item = getItem(item);\n            (0, _assert.default)(Array.isArray(item), \"item must be Array\");\n            mergedConfig = {};\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context.prev = 6;\n            _iterator = item[Symbol.iterator]();\n\n          case 8:\n            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n              _context.next = 19;\n              break;\n            }\n\n            config = _step.value;\n\n            if (!(0, _utils.isPromiseLike)(config)) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.next = 13;\n            return config;\n\n          case 13:\n            config = _context.sent;\n\n          case 14:\n            (0, _assert.default)((0, _isPlainObject.default)(config), \"Config is not plain object\");\n            mergedConfig = _objectSpread({}, mergedConfig, {}, config);\n\n          case 16:\n            _iteratorNormalCompletion = true;\n            _context.next = 8;\n            break;\n\n          case 19:\n            _context.next = 25;\n            break;\n\n          case 21:\n            _context.prev = 21;\n            _context.t0 = _context[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 25:\n            _context.prev = 25;\n            _context.prev = 26;\n\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n\n          case 28:\n            _context.prev = 28;\n\n            if (!_didIteratorError) {\n              _context.next = 31;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 31:\n            return _context.finish(28);\n\n          case 32:\n            return _context.finish(25);\n\n          case 33:\n            return _context.abrupt(\"return\", mergedConfig);\n\n          case 34:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 21, 25, 33], [26,, 28, 32]]);\n  }));\n  return _mergeConfigAsync.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}